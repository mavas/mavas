# Things I've done with C/C++

- I first started out with C++, and then much later learned Python.  Some say you get a different kind of engineer from the one that learns Python first and then has to learn C.  I understood the call stack, walked through things slowly with the **gdb** tool, made a game loop with it, etc.  The first compiler that I found that worked decent was Borland C++, which is still around today.  I used to lookup www.cplusplus.com **constantly**, and that web site is still up and looks the same.  C++ allows for very under-the-hood understanding of exactly how things are performed by the machine/computer, whereas Python is designed to hide these types of things.. automatic garbage collection for example (versus manually freeing memory).  Once you have a good grasp of the syntax for argument-passing (call by reference or call by value?), then you never mess it up again and you can focus.

- **Olimar's Escape** is a text text-based RPG game I made.  It features a game loop - of course - and is incomplete, but taught me that things can get big really quickly.  I had to start coming up with characters, and stories, and scenes, and speach, and items that need to go in the rooms, and all kinds of things.  It takes a lot to make a full video game.  The code is [here](https://github.com/mavas/Olimar-Escape).  The important thing about this though is that I was thinking entirely at a high level while programming this using only C++; in other words, I was thinking about _a whole game_, in standard C++.  No other libraries were used, so it's just using raw C++, to make a text-based RPG game.

- I kind of got into the Boost libraries but didn't stay around for too long, it turns out.  I did Google's Summer of Code and used Boost.Python to make C++ bindings between C++ and Python.  There were numerous other options at the time but we settled on Boost.  The project ended up not using my work and using some other language binding tool.  OpenCog uses Boost extensively and successfully, and I have had to deal with that codebase before.

- I once found the [DexDrive](https://github.com/fbriere/linux-dexdrive) Linux C code on the THIRD page of a Google search, and then downloaded it compiled it and ran it, in order to save songs I had made on a video game for a Playstation memory card.  It's a non-standard device, that you feed your memory cards into, and it can transfer the data to your computer for backup purposes.  The device surely works for Windows, but I had to find the code online for Linux, and it was in some random person's repository.  This is one of those classic examples of hardware and/or software written for Windows, but you can still find an open source Linux driver somewhere and it works great and is better than the Windows software that never gets updated.

- Compiling OpenCV for the Python language bindings.  It's always best to manually go to the opencv.org web site and download and extract the source code and compile it yourself using the CMake tool.  Practically the only reason to need to deal with compiling OpenCV's source code is when you want access to the Python language bindings.  For this, you have to add certain flags to your "cmake -DCMAKE_BUILD_TYPE=Debug .." command, and then you find the **cv2.so** file in there somewhere.  CMake is pretty nice in that it's much easier to deal with than Makefiles; CMake _generates_ Makefiles.

- I once had to work a full-time job doing C++ investigative development for a data operation.  I had to create a custom binary which moved data from place to another, likely with Apache Flume or similar.  This was in the last 5 years, and is my most recent and professional C++ experience.

- All too often, you're on the web and you download some code and you have to compile it and deal with it, and this code is in C or C++, and you have to actually mess (edit the code and recompile) with it.  Often times is a small amount of code, like the kind that would interface with a toaster.  Take [Packet Storm Security](https://www.packetstormsecurity.com/).

- Firmware is pretty important.  chipsec is a cool tool.  I heard lately that GoLang is popular with malware authors; I don't know the language yet.  ThinkPwn is a nasty exploit that deals with the UEFI stuff, that I've been reading about lately.

# C++'s relationship to C

I think I prefer C, because maybe that templating stuff isn't too necessary, but some libraries make heavy use of dlib and Boost.  I had a copy of the classic K&R book.
